\chapter{Approximation}

A 2-approximation algorithm for finding a hamiltonian cycle in the square of a biconnected graph was described by Parker and Rardin in~\cite{ParkerRardin1984}. \cite{alstrup2018hamiltonian} gives an improved version with a runtime linear in the number of edges in the graph.

\section{An approximation algorithm for BTSP}
In this section we compare the algorithms from~\cite{ParkerRardin1984} and~\cite{alstrup2018hamiltonian} and discuss the actual implementation.

On a very abstract level the algorithms contain of three steps:
\begin{enumerate}
  \item find a bottleneck optimal biconnected subgraph
  \item compute an open ear decomposition of that subgraph
  \item find an approximate solution using the open ear decomposition\label{enum:approximate}
\end{enumerate}

\subsection{Finding a bottleneck optimal biconnected subgraph}
The bottleneck optimal biconnected subgraph is the graph whose longest edge is shortest among all biconnected subgraphs.
Parker and Rardin~\cite{ParkerRardin1984} presented an easy implementable algorithm for finding such a subgraph: First all edges are sorted ascending in their weight and then edges are picked from the list until the graph is biconnected. Sorting costs \(\mathcal{O}(\abs{E} \log \abs{E})\) and the \(\mathcal{O}(\abs{E})\) checks for biconnectivity can be performed in \(\mathcal{O}(\abs{E}^2)\) when using Schmidts algorithm~\cite{schmidt2013}. This leads to an overall runtime of \(\mathcal{O}(\abs{E}^2)\). We will come back to have a closer look the schmidt algorithm in section~\ref{subsec:open_ear_decomposition}.

In contrary in~\cite{alstrup2018hamiltonian} the much more sophisticated algorithm from~\cite{han1995} comes into play. This has two advantages over the naive approach:
\begin{enumerate}
  \item It has linear runtime.
  \item The algorithm produces a minimally biconnected subgraph.
\end{enumerate}
The second feature is a requirement for the algorithm presented to achieve step~\ref{enum:approximate}.

However, the algorithm by Han, Kelsen, Ramachandran and Tarjan comes with some drawbacks:
\begin{enumerate}
  \item The linear runtime comes with large constants.
  \item The algorithm is very bulky and craves very complex memory structures to obtain the proposed linear runtime in practical implementation.
\end{enumerate}

Therefore, the actual implementation (Algorithm~\ref{alg:biconnected_subgraph}) sticks to the naive approach with some improvements regarding performance.

\begin{algorithm}[ht!]
  \caption{Finding a bottleneck optimal biconnected subgraph}\label{alg:biconnected_subgraph}
  \textbf{Input:} complete graph \(K_n = (V, V \times V)\)\\
  \textbf{Output:} bottleneck optimal biconnected subgraph \(G\)
  \begin{algorithmic}[1]
    \Procedure{biconnectedSubgraph} {$K_n$}
      \State set \(G \coloneqq (V, \emptyset)\)
      \State order edges ascending in length
      \State add the first \(n\) edges to \(G\)\label{code:add_n_edges}
      \While{\(G\) not biconnected}
        \State add next edge from the list to \(G\)
      \EndWhile
      \State\Return{\(G\)}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

% DIREKT BISECTION SEARCH BESCHREIBEN
In line~\ref{code:add_n_edges}, we add \(n\) edges at once without checking for biconnectivity because every biconnected graph with \(n\) vertices has at least \(n\) edges. This bound is tight in case the biconnected subgraph is a cycle. As in the original algorithm by Rardin and Parker the runtime is \(\O{\abs{E}^2}\), but by replacing the while loop with a bisection search it can be improved to \(\O{\abs{E}\log \abs{E}}\).

\begin{algorithm}[ht!]
  \caption{Making minimally biconnected}\label{alg:minimally_biconnected}
  \textbf{Input: } bottleneck optimal biconnected graph \(G = (V_G, E_G)\)\\
  \textbf{Output: } bottleneck optimal minimally biconnected graph \(G\)
  \begin{algorithmic}[1]
    \Procedure{makeMinimallyBiconnected}{$G$}
      \For{edge \(e\) in \(E_G\)}
        \If{\(G \backslash e\) is biconnected}
          \State remove \(e\) from \(G\)
        \EndIf
      \EndFor
      \State \Return{G}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

To meet the requirement for the step~\ref{enum:approximate} algorithm we iterate over all edges \(E_G\) in the graph \(G = (V_G, E_G)\) obtained from algorithm~\ref{alg:biconnected_subgraph} and remove an edge \(e = (u, v)\) if \(G \backslash e\) is still biconnected. Again a check for biconnectivity using Schmidts algorithm can be done in \(\O{\abs{E_G}}\), but if the degree of \(u\) or \(v\) is at most two this already proofs \(e\) \(k\)-essential. Therefore, the runtime is \(\O{\abs{{E_G}}^2}\).

\subsection{Computing an open ear decomposition}\label{subsec:open_ear_decomposition}

An open ear decomposition is a partitioning of a graphs edge set \(E\) into paths, exactly one of which is a cycle. Moreover, all these paths, which are called ears, together must form a sequence starting with the cycle where each end vertex of an ear must be inner vertex of a preceding ear.
Such an open ear decomposition exists if and only if the graph is biconnected.
Given any graph \(G\) the schmidt algorithm either finds an open ear decomposition in \(G\) or detects that \(G\) is not biconnected. The implementation has one version for checking biconnectivity and one for finding an open ear decomposition to reduce the overhead in both cases. Both omit the check for \(2\)-edge-connectivity contained in schmidts original algorithm~\cite{schmidt2013}.

To avoid redundancy algorithm~\ref{alg:schmidt} combines both purposes. Here we use the weaker term \enquote{chain} as in~\cite{schmidt2013} instead of \enquote{ear} because at this point we do not know if the graph has a proper ear decomposition and the chains are indeed ears.
First, we perform a \gls{dfs} with arbitrary root \(r\) node on the given graph \(G = (V, E)\). From that we store a \gls{dfstree} containing the order the nodes are explored during the \gls{dfs} and the edge to its parent node for each node except for the root node \(r\). These edges together are \(E_T\) where the \gls{dfstree} is \(T \coloneqq (V_T, E_T)\).
If there is a node not appearing in the \gls{dfstree} that is \(V \neq V_T\), then \(G\) is not even connected and hence not biconnected.
We put all edges not contained in the \gls{dfstree} in the set \(B \coloneqq E \backslash E_T\) and call them \enquote{backedges}. Next we mark all nodes as unvisited before we iterate over all nodes \(u \in V\) in the order they are discovered by the \gls{dfs}.
For all backedges \((u,v) \in B\) where \(v\) is still unvisited, we form a chain \(C\) starting with the backedge \((u,v)\). By adding the restriction we skip considering all trivial chains consisting of a single edge. From \(v\) we trace back up the \gls{dfstree} until we reach an already visited node. Note that in the very first iteration chain starts and ends with \(u = r\) and hence is a cycle.
% refference to definition of articulation point
If this happens again later in the algorithm with another node \(w\), then \(w\) is an articulation point and thus \(G\) is not biconnected. If all nodes in \(G\) are visited after the iterations, \(G\) is biconnected and all chains are ears.

\begin{algorithm}
  \caption{Schmidt algorithm}\label{alg:schmidt}
  \textbf{Input: } graph \(G = (V, E)\)\\
  \textbf{Output: } open ear decomposition result that \(G\) is not biconnected
  \begin{algorithmic}[1]
    \Procedure{schmidt}{$G = (V, E)$}
      \State pick an arbitrary root node \(r \in V\)
      \State perform a \gls{dfs} on \(G\) starting with \(r\) to get \gls{dfstree} \(T = (V, E_T)\)
      \If{\(G\) not connected}
        \State\Return{\(G\) is not biconnected}
      \EndIf
      \State set the set of backedges \(B \coloneqq E \backslash E_T\)
      \State mark all nodes as unvisited
      \For{all nodes \(u \in V\) in the order they are explored by the \gls{dfs}}
        \For{all \(v\) with \((u,v) \in B\)}
          \If{\(v\) is unvisited}
            \State mark \(u\) as visited
            \State start a new chain \(C \coloneqq (u, v)\)
            \While{\(v\) is unvisited}
              \State mark \(v\) as visited
              \State set \(v\) to its parent in the \gls{dfstree}
              \State append \(v\) to \(C\)
              \If{\(v = u\) but \(v \neq r\)}
                \State\Return{\(G\) is not biconnected}
              \EndIf
            \EndWhile
            \State append \(C\) to the list of chains
          \EndIf
        \EndFor
      \EndFor
      \For{all \(v \in V\)}
        \If{\(v\) is unvisited}
          \State\Return{\(G\) is not biconnected}
        \EndIf
      \EndFor
      \State\Return{\(G\) is biconnected}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{Finding an approximate solution}
Having an open ear decomposition the following steps lead to the approximate solution:
\begin{enumerate}
  \item add and delete edges in the open ear decomposition to make it an eulerian graph
  \item find a suitable euler tour in the graph
  \item shortcut the euler tour to hamilton cycle in the square of the original graph
\end{enumerate}

\section{An approximation algorithm for BTSPP}