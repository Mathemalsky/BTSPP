\chapter{Approximation}

A 2-approximation algorithm for finding a hamiltonian cycle in the square of a biconnected graph was described by Parker and Rardin in~\cite{ParkerRardin1984}. \cite{alstrup2018hamiltonian} gives an improved version with a runtime linear in the number of edges in the graph.

\section{An approximation algorithm for BTSP}
In this section we compare the algorithms from~\cite{ParkerRardin1984} and~\cite{alstrup2018hamiltonian} and discuss the actual implementation.

On a very abstract level the algorithms contain of three steps:
\begin{enumerate}
  \item find a bottleneck optimal biconnected subgraph
  \item compute an open ear decomposition of that subgraph
  \item find an approximate solution using the open ear decomposition\label{enum:approximate}
\end{enumerate}

\subsection{Finding a bottleneck optimal biconnected subgraph}
The bottleneck optimal biconnected subgraph is the graph whose longest edge is shortest among all biconnected subgraphs.
Parker and Rardin~\cite{ParkerRardin1984} presented an easy implementable algorithm for finding such a subgraph: First all edges are sorted ascending in their weight and then edges are picked from the list until the graph is biconnected. Sorting costs \(\mathcal{O}(\abs{E} \log \abs{E})\) and the \(\mathcal{O}(\abs{E})\) checks for biconnectivity can be performed in \(\mathcal{O}(\abs{E}^2)\) when using Schmidts algorithm~\cite{schmidt2013}. This leads to a overall runtime of \(\mathcal{O}(\abs{E}^2)\).

In contrary in~\cite{alstrup2018hamiltonian} the much more sophisticated algorithm from~\cite{han1995} comes into play. This has two advantages over the naive approach:
\begin{enumerate}
  \item It has linear runtime.
  \item The algorithm produces a minimally biconnected subgraph.
\end{enumerate}
The second feature is a requirement for the algorithm presented to achieve step~\ref{enum:approximate}.

However, the algorithm by Han, Kelsen, Ramachandran and Tarjan comes with some drawbacks:
\begin{enumerate}
  \item The linear runtime comes with large constants.
  \item The algorithm is very bulky and craves very complex memory structures to obtain the proposed linear runtime in practical implementation.
\end{enumerate}

Therefore, the actual implementation (Algorithm~\ref{alg:biconnected_subgraph}) sticks to the naive approach with some improvements.

\begin{algorithm}[ht!]
  \caption{Finding a bottleneck optimal biconnected subgraph}\label{alg:biconnected_subgraph}
  \textbf{Input:} complete graph \(K_n = (V, V \times V)\)\\
  \textbf{Output:} bottleneck optimal biconnected subgraph
  \begin{algorithmic}[1]
    \Procedure{biconnectedSubgraph} {$K_n$}
      \State set \(H \coloneqq (V, \emptyset)\)
      \State order edges ascending in length
      \State add the first \(n\) edges to \(H\)\label{code:add_n_edges}
      \While{\(H\) not biconnected}
        \State add next edge from the list to \(H\)
      \EndWhile
      \State\Return{\(H\)}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

In line~\ref{code:add_n_edges}, we add \(n\) edges at once without checking for biconnectivity because every biconnected graph with \(n\) vertices has at least \(n\) edges. This bound is tight in case the biconnected subgraph is a cycle. As in the original algorithm by Rardin and Parker the runtime is \(\O{\abs{E}^2}\), but by replacing the while loop with a bisection search it can be improved to \(\O{\abs{E}\log \abs{E}}\).

\begin{algorithm}[ht!]
  \caption{Making minimally biconnected}\label{alg:minimally_biconnected}
  \textbf{Input: } bottleneck optimal biconnected graph \(H = (V_H, E_H)\)\\
  \textbf{Output: } bottleneck optimal minimally biconnected graph \(H\)
  \begin{algorithmic}[1]
    \Procedure{makeMinimallyBiconnected}{$H$}
      \For{edge \(e\) in \(E\)}
        \If{\(H \backslash e\) is biconnected}
          \State remove \(e\) from \(H\)
        \EndIf
      \EndFor
      \State \Return{H}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

To meet the requirement for the step~\ref{enum:approximate} algorithm we iterate over all edges \(E_H\) in the graph \(H = (V_H, E_H)\) obtained from algorithm~\ref{alg:biconnected_subgraph} and remove an edge \(e = (u, v)\) if \(H \backslash e\) is still biconnected. Again a check for biconnectivity using Schmidts algorithm can be done in \(\O{\abs{E_H}}\), but if the degree of \(u\) or \(v\) is at most two this already proofs \(e\) \(k\)-essential. Therefore, the runtime is \(\O{\abs{{E_H}}^2}\).

\subsection{Computing an open ear decomposition}
\subsection{Finding an approximate solution}

\section{An approximation algorithm for BTSPP}