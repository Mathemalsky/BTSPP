\chapter{Approximation}

A 2-approximation algorithm for finding a hamiltonian cycle in the square of a biconnected graph was described by Parker and Rardin in~\cite{ParkerRardin1984}. \cite{alstrup2018hamiltonian} gives an improved version with a runtime linear in the number of edges in the graph.

\section{An approximation algorithm for BTSP}
In this section we compare the algorithms from~\cite{ParkerRardin1984} and~\cite{alstrup2018hamiltonian} and discuss the actual implementation.

On a very abstract level the algorithms contain of three steps:
\begin{enumerate}
  \item find a bottleneck optimal biconnected subgraph
  \item compute an open ear decomposition of that subgraph
  \item find an approximate solution using the open ear decomposition\label{enum:approximate}
\end{enumerate}

\subsection{Finding a bottleneck optimal biconnected subgraph}
The bottleneck optimal biconnected subgraph is the graph whose longest edge is shortest among all biconnected subgraphs.
Parker and Rardin~\cite{ParkerRardin1984} presented an easy implementable algorithm for finding such a subgraph: First all edges are sorted ascending in their weight and then edges are picked from the list until the graph is biconnected. Sorting costs \(\mathcal{O}(\abs{E} \log \abs{E})\) and the \(\mathcal{O}(\abs{E})\) checks for biconnectivity can be performed in \(\mathcal{O}(\abs{E}^2)\) when using Schmidts algorithm~\cite{schmidt2013}. This leads to an overall runtime of \(\mathcal{O}(\abs{E}^2)\). We will come back to have a closer look the schmidt algorithm in section~\ref{subsec:open_ear_decomposition}.

In contrary in~\cite{alstrup2018hamiltonian} the much more sophisticated algorithm from~\cite{han1995} comes into play. This has two advantages over the naive approach:
\begin{enumerate}
  \item It has linear runtime.
  \item The algorithm produces a minimally biconnected subgraph.
\end{enumerate}
The second feature is a requirement for the algorithm presented to achieve step~\ref{enum:approximate}.

However, the algorithm by Han, Kelsen, Ramachandran and Tarjan comes with some drawbacks:
\begin{enumerate}
  \item The linear runtime comes with large constants.
  \item The algorithm is very bulky and craves very complex memory structures to obtain the proposed linear runtime in practical implementation.
\end{enumerate}

Therefore, the actual implementation (Algorithm~\ref{alg:biconnected_subgraph}) sticks to the naive approach with some improvements regarding performance.

\begin{algorithm}[ht!]
  \caption{Finding a bottleneck optimal biconnected subgraph}\label{alg:biconnected_subgraph}
  \textbf{Input:} complete graph \(K_n = (V, V \times V)\)\\
  \textbf{Output:} bottleneck optimal biconnected subgraph \(G\)
  \begin{algorithmic}[1]
    \Procedure{biconnectedSubgraph} {$K_n$}
      \State set \(G \coloneqq (V, \emptyset)\)
      \State order edges ascending in length
      \State add the first \(n\) edges to \(G\)\label{code:add_n_edges}
      \While{\(G\) not biconnected}
        \State add next edge from the list to \(G\)
      \EndWhile
      \State\Return{\(G\)}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

% DIREKT BISECTION SEARCH BESCHREIBEN
In line~\ref{code:add_n_edges}, we add \(n\) edges at once without checking for biconnectivity because every biconnected graph with \(n\) vertices has at least \(n\) edges. This bound is tight in case the biconnected subgraph is a cycle. As in the original algorithm by Rardin and Parker the runtime is \(\O{\abs{E}^2}\), but by replacing the while loop with a bisection search it can be improved to \(\O{\abs{E}\log \abs{E}}\).

\begin{algorithm}[ht!]
  \caption{Making minimally biconnected}\label{alg:minimally_biconnected}
  \textbf{Input: } bottleneck optimal biconnected graph \(G = (V_G, E_G)\)\\
  \textbf{Output: } bottleneck optimal minimally biconnected graph \(G\)
  \begin{algorithmic}[1]
    \Procedure{makeMinimallyBiconnected}{$G$}
      \For{edge \(e\) in \(E_G\)}
        \If{\(G \backslash e\) is biconnected}
          \State remove \(e\) from \(G\)
        \EndIf
      \EndFor
      \State \Return{G}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

To meet the requirement for the step~\ref{enum:approximate} algorithm we iterate over all edges \(E_G\) in the graph \(G = (V_G, E_G)\) obtained from algorithm~\ref{alg:biconnected_subgraph} and remove an edge \(e = (u, v)\) if \(G \backslash e\) is still biconnected. Again a check for biconnectivity using Schmidts algorithm can be done in \(\O{\abs{E_G}}\), but if the degree of \(u\) or \(v\) is at most two this already proofs \(e\) \(k\)-essential. Therefore, the runtime is \(\O{\abs{{E_G}}^2}\).

\subsection{Computing an open ear decomposition}\label{subsec:open_ear_decomposition}

An open ear decomposition is a partitioning of a graphs edge set \(E\) into paths, exactly one of which is a cycle. Moreover, all these paths, which are called ears, together must form a sequence starting with the cycle where each end vertex of an ear must be inner vertex of a preceding ear.
Such an open ear decomposition exists if and only if the graph is biconnected.
Given any graph \(G\) the schmidt algorithm either finds an open ear decomposition in \(G\) or detects that \(G\) is not biconnected. The implementation has one version for checking biconnectivity and one for finding an open ear decomposition to reduce the overhead in both cases. Both omit the check for \(2\)-edge-connectivity contained in schmidts original algorithm~\cite{schmidt2013}.

To avoid redundancy algorithm~\ref{alg:schmidt} combines both purposes. Here we use the weaker term \enquote{chain} as in~\cite{schmidt2013} instead of \enquote{ear} because at this point we do not know if the graph has a proper ear decomposition and the chains are indeed ears.
First, we perform a \gls{dfs} with arbitrary root \(r\) node on the given graph \(G\). From that we store a \gls{dfs}-tree containing the order the nodes are explored during the \gls{dfs} and the parent node for each node except for the root node \(r\). If there is a node not appearing in the \gls{dfs}-tree, then \(G\) is not even connected and hence not biconnected. Next we mark all nodes as unvisited before we iterate over all nodes in the order they are discovered by the \gls{dfs}.
% FORTSETZEN

\begin{algorithm}[ht!]
  \caption{Schmidt algorithm}\label{alg:schmidt}
  \textbf{Input: } graph \(G = (V, E)\)\\
  \textbf{Output: }
  \begin{algorithmic}[1]
    \Procedure{schmidt}{$G = (V, E)$}
      \State pick an arbitrary root node \(r \in V\)
      \State perform a \gls{dfs} on \(G\) starting with \(r\)
      \If{\(G\) not connected}
        \State\Return{\(G\) is not biconnected}
      \EndIf
      \State mark all nodes as unvisited
      \For{all nodes \(u \in V\) in the order they are explored by the \gls{dfs}}
        \For{all unvisited neighbours \(v\) of \(u\)}
          \If{\(v\) is unvisited}
            \State mark \(u\) as visited
            \While{\(v\) is unvisited}
              \State mark \(v\) as visited
              \State set \(v\) to its parent in the \gls{dfs}-tree
              \If{\(v = u\) but \(v \neq r\)}
                \State\Return{\(G\) is not biconnected}
              \EndIf
            \EndWhile
          \EndIf
        \EndFor
      \EndFor
      \For{all \(v \in V\)}
        \If{\(v\) is unvisited}
          \State\Return{\(G\) is not biconnected}
        \EndIf
      \EndFor
      \State\Return{\(G\) is biconnected}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{Finding an approximate solution}

\section{An approximation algorithm for BTSPP}