\chapter{Approximation}

In~\cite{garfinkel1978} Garfinkel and Gilbert proved, that no approximation algorithm for \gls{btsp} can exist, unless \(P = NP\), if edge weights can take arbitrary numbers. So we limit ourselves to graphs where the edge weights are non-negative and fulfil the triangle inequality. Mostly we focus on graphs with symmetric edge weights. That means \(\wt(e_{uv}) = \wt(e_{vu}) \,\, \forall (e,u)\) in the graphs edge set \(E\). Then we call the \gls{btsp} a metric \gls{btsp} because the edge weights comply with all 3 properties of a metric.
A 2-approximation algorithm for finding a hamiltonian cycle in the square of a biconnected graph was described by Parker and Rardin in 1984~\cite{ParkerRardin1984}. \cite{alstrup2018hamiltonian} gives an improved version with a runtime linear in the number of edges in the graph.

\section{An approximation algorithm for BTSP}
In this section we compare the algorithms from~\cite{ParkerRardin1984} and~\cite{alstrup2018hamiltonian} and discuss the actual implementation.

On a very abstract level the algorithms contain of three steps:
\begin{enumerate}[label={Step \arabic*:}, wide = 1em, leftmargin = 3em]
  \item find a bottleneck optimal biconnected subgraph
  \item compute an open ear decomposition of that subgraph
  \item find an approximate solution using the open ear decomposition\label{enum:approximate}
\end{enumerate}

\subsection{Finding a bottleneck optimal biconnected subgraph}
The bottleneck optimal biconnected subgraph is the graph whose longest edge is shortest among all biconnected subgraphs.
Parker and Rardin~\cite{ParkerRardin1984} presented an easy implementable algorithm for finding such a subgraph: First all edges are sorted ascending in their weight and then edges are picked from the list until the graph is biconnected. Sorting costs \(\mathcal{O}(\abs{E} \log \abs{E})\) and the \(\mathcal{O}(\abs{E})\) checks for biconnectivity can be performed in \(\mathcal{O}(\abs{E}^2)\) when using Schmidts algorithm~\cite{schmidt2013}. This leads to an overall runtime of \(\mathcal{O}(\abs{E}^2)\). We will come back to have a closer look the schmidt algorithm in section~\ref{subsec:open_ear_decomposition}.

In contrary in~\cite{alstrup2018hamiltonian} the much more sophisticated algorithm from~\cite{han1995} comes into play. This has two advantages over the naive approach:
\begin{enumerate}
  \item It has linear runtime.
  \item The algorithm produces a minimally biconnected subgraph.
\end{enumerate}
The second feature is a requirement for the algorithm presented to achieve step~\ref{enum:approximate}.

However, the linear runtime algorithm by Han, Kelsen, Ramachandran and Tarjan comes with some drawbacks:
\begin{enumerate}
  \item The linear runtime comes with large constants.
  \item The algorithm is very bulky and craves very complex memory structures to obtain the proposed linear runtime in practical implementation.
\end{enumerate}

Therefore, the actual implementation (Algorithm~\ref{alg:biconnected_subgraph}) sticks to the naive approach with some improvements regarding performance.

\begin{algorithm}[ht!]
  \caption{Finding a bottleneck optimal biconnected subgraph}\label{alg:biconnected_subgraph}
  \textbf{Input:} complete graph \(K_n = (V, V \times V)\)\\
  \textbf{Output:} bottleneck optimal biconnected subgraph \(G\)
  \begin{algorithmic}[1]
    \Procedure{biconnectedSubgraph} {$K_n$}
      \State set \(G \coloneqq (V, \emptyset)\)
      \State order edges ascending in length
      \State add the first \(n\) edges to \(G\)\label{code:add_n_edges}
      \State use bisection search to figure out how many more edges are needed 
      \State\Return{\(G\)}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

In line~\ref{code:add_n_edges}, we add shortest \(n\) edges at once without checking for biconnectivity because every biconnected graph with \(n\) vertices has at least \(n\) edges. This bound is tight in case the biconnected subgraph is a cycle. In the original algorithm by Parker and Rardin the check for biconnected after each inserted edge was the bottleneck of runtime. By replacing it with a bisection search we obtain an overall runtime of \(\O{\abs{E}\log \abs{E}}\) for the \hyperref[alg:biconnected_subgraph]{algorithm}.

\begin{algorithm}[ht!]
  \caption{Making minimally biconnected}\label{alg:minimally_biconnected}
  \textbf{Input: } bottleneck optimal biconnected graph \(G = (V_G, E_G)\)\\
  \textbf{Output: } bottleneck optimal minimally biconnected graph \(G\)
  \begin{algorithmic}[1]
    \Procedure{makeMinimallyBiconnected}{$G$}
      \For{edge \(e\) in \(E_G\)}
        \If{\(G \backslash e\) is biconnected}
          \State remove \(e\) from \(G\)
        \EndIf
      \EndFor
      \State \Return{G}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

To meet the requirement for the step~\ref{enum:approximate} algorithm we iterate over all edges \(E_G\) in the graph \(G = (V_G, E_G)\) obtained from algorithm~\ref{alg:biconnected_subgraph} and remove an edge \(e = (u, v)\) if \(G \backslash e\) is still biconnected. Again a check for biconnectivity using Schmidts algorithm can be done in \(\O{\abs{E_G}}\), but if the degree of \(u\) or \(v\) is at most two this already proofs \(e\) \(k\)-essential. Therefore, the runtime is \(\O{\abs{{E_G}}^2}\).

\subsection{Computing an open ear decomposition}\label{subsec:open_ear_decomposition}

An open ear decomposition is a partitioning of a graphs edge set \(E\) into paths, exactly one of which is a cycle. Moreover, all these paths, which are called ears, together must form a sequence starting with the cycle where each end vertex of an ear must be inner vertex of a preceding ear.
Such an open ear decomposition exists if and only if the graph is biconnected.
Given any graph \(G\) the schmidt algorithm either finds an open ear decomposition in \(G\) or detects that \(G\) is not biconnected. The implementation has one version for checking biconnectivity and one for finding an open ear decomposition to reduce the overhead in both cases. Both omit the check for \(2\)-edge-connectivity contained in schmidts original algorithm~\cite{schmidt2013}.

To avoid redundancy algorithm~\ref{alg:schmidt} combines both purposes. Here we use the weaker term \enquote{chain} as in~\cite{schmidt2013} instead of \enquote{ear} because at this point we do not know if the graph has a proper ear decomposition and the chains are indeed ears.
First, we perform a \gls{dfs} with arbitrary root \(r\) node on the given graph \(G = (V, E)\). From that we store a \gls{dfstree} containing the order the nodes are explored during the \gls{dfs} and the edge to its parent node for each node except for the root node \(r\). These edges together are \(E_T\) where the \gls{dfstree} is \(T \coloneqq (V_T, E_T)\).
If there is a node not appearing in the \gls{dfstree} that is \(V \neq V_T\), then \(G\) is not even connected and hence not biconnected.
We put all edges not contained in the \gls{dfstree} in the set \(B \coloneqq E \backslash E_T\) and call them \enquote{backedges}. Next we mark all nodes as unvisited before we iterate over all nodes \(u \in V\) in the order they are discovered by the \gls{dfs}.
For all backedges \((u,v) \in B\) where \(v\) is still unvisited, we form a chain \(C\) starting with the backedge \((u,v)\). By adding the restriction we skip considering all trivial chains consisting of a single edge. From \(v\) we trace back up the \gls{dfstree} until we reach an already visited node. Note that in the very first iteration chain starts and ends with \(u = r\) and hence is a cycle.
If this happens again later in the algorithm with another node \(w\), then \(w\) is an \hyperref[def:articulation_point]{articulation point} and thus \(G\) is not biconnected. If all nodes in \(G\) are visited after the iterations, \(G\) is biconnected and all chains are ears.

\begin{algorithm}
  \caption{Schmidt algorithm}\label{alg:schmidt}
  \textbf{Input: } graph \(G = (V, E)\)\\
  \textbf{Output: } open ear decomposition result that \(G\) is not biconnected
  \begin{algorithmic}[1]
    \Procedure{schmidt}{$G = (V, E)$}
      \State pick an arbitrary root node \(r \in V\)
      \State perform a \gls{dfs} on \(G\) starting with \(r\) to get \gls{dfstree} \(T = (V, E_T)\)
      \If{\(G\) not connected}
        \State\Return{\(G\) is not biconnected}
      \EndIf
      \State set the set of backedges \(B \coloneqq E \backslash E_T\)
      \State mark all nodes as unvisited
      \For{all nodes \(u \in V\) in the order they are explored by the \gls{dfs}}
        \For{all \(v\) with \((u,v) \in B\)}
          \If{\(v\) is unvisited}
            \State mark \(u\) as visited
            \State start a new chain \(C \coloneqq (u, v)\)
            \While{\(v\) is unvisited}
              \State mark \(v\) as visited
              \State set \(v\) to its parent in the \gls{dfstree}
              \State append \(v\) to \(C\)
              \If{\(v = u\) but \(v \neq r\)}
                \State\Return{\(G\) is not biconnected}
              \EndIf
            \EndWhile
            \State append \(C\) to the list of chains
          \EndIf
        \EndFor
      \EndFor
      \For{all \(v \in V\)}
        \If{\(v\) is unvisited}
          \State\Return{\(G\) is not biconnected}
        \EndIf
      \EndFor
      \State\Return{\(G\) is biconnected}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

If \(G\) is biconnected, we went over each edge in \(E\) exactly once during the \hyperref[alg:schmidt]{algorithm}. Either as backedge or as edge to its parent. In case the graph is not biconnected the algorithm terminates prematurely. So it terminates in \(\O{\abs{E}}\).
% A property of an open ear decomposition is that every ear hast at least one inner vertex.

\subsection{Finding an approximate solution}
Having an open ear decomposition the following steps lead to the approximate solution:
\begin{enumerate}
  \item add and delete edges in the open ear decomposition to make it an eulerian graph
  \item find a suitable euler tour in the graph
  \item shortcut the euler tour to hamilton cycle in the square of the original graph
\end{enumerate}

The general idea of the algorithm in~\cite{alstrup2018hamiltonian} is to walk along the edges in the open ear decomposition, starting and ending on an arbitrary node and thereby visiting all other nodes exactly once. We are allowed to skip up to one node row, and we may come back and walk edges again. Note that we can walk edges at most twice because we cannot skip both of its end vertices and no node can be visited twice. On the other hand it is possible to shun edges completely.

\subsection{Proving the approximation guarantee}
Every hamiltonian cycle in a graph \(G = (V, E)\) is biconnected. Thus, the weight \(Z^\ast\) of the longest edge in the bottleneck optimal biconnected subgraph \(G^\ast\) is a lower bound on value OPT of the bottleneck optimal hamiltonian cycle. In step~\ref{enum:approximate} we shortcut pairs of edges from \(G^\ast\) into one. By triangle inequality this edge is no long than the sum of both edges from the pair.
So for the objective function value \(\hat{Z}\) of a solution obtained by our approximation algorithm we have:
\begin{equation}
  \hat{Z} \stackrel{\Delta-\text{ineq.}}{\leq} 2 Z^\ast \stackrel{Z^\ast \leq OPT}{\leq} 2 \, OPT
\end{equation}
A typical approach is to take a look at the parameterized triangle inequality, like in~\cite{bender1999generalizedTriangle}, and indeed we can even generalize these result for graphs complying with the parameterized triangle inequality, which is
\begin{equation}
  \wt(e_{uw}) \leq \tau \left(\wt\left(e_{uv}\right) + \wt\left(e_{vw}\right)\right)\label[equation]{eq:tau_inequality}
\end{equation}
for \(e_{uv}, e_{vw}, e_{uw} \in E\) with \(u,v,w \in V\) and pairwise distinct. For \(\tau \in [0.5,1)\) inequality is tightened whereas for \(\tau > 1\) it is a relaxation.
For a graph that meets the \(\tau\)-triangle inequality we get
\begin{equation}
  \hat{Z} \stackrel{\tau-\Delta-\text{ineq.}}{\leq} 2 \tau Z^\ast \stackrel{Z^\ast \leq OPT}{\leq} 2 \tau \, OPT.
\end{equation}

\subsection{Optimality of approximation factor}
In theorem 3 of their work~\cite{ParkerRardin1984} Parker and Rardin proved that the existence an approximation algorithm with approximation factor smaller than \(2\) would imply \(P = NP\). The proof - and thus the result - can be generalized to the parameterized triangle inequality.

\begin{theorem}
  For general graphs with non-negative symmetric weights satisfying the \(\tau\)-triangle inequality~\eqref{eq:tau_inequality}, there is no approximation algorithm \(\mathcal{A}\) with approximation guarantee \(f < 2\tau\) unless \(P = NP\).
\end{theorem}

\begin{proof}
  Let's pretend we have an approximation algorithm \(\mathcal{A}\) with approximation guarantee \(f < 2\tau\). Then we can use \(\mathcal{A}\) to test an arbitrary graph \(G = (V,E)\) for hamiltonicity in polynomial time. To do so, we put weights on the complete graph \(K_\abs{V} = (V, V \times V)\).
  \begin{equation*}
    \forall e \in V \times V \quad \wt(e) \coloneqq \begin{cases}
      1 \quad e \in E \\
      2 \tau \quad \text{else}
    \end{cases}
  \end{equation*}
  Obviously a graph with such weights obeys the \(tau\)-triangle inequality. If \(G\) is hamiltonian \(\mathcal{A}\) finds a hamilton cycle in \(K_\abs{V}\) including only edge with weight \(< 2\tau\). So all edges must be in \(E\). Hence, by checking if the value of the solution from \(\mathcal{A}\) one can decide if \(G\) is hamiltonian or not, but to decide if a general graph like \(G\) is hamiltonian is known to be (NP-complete). Therefore, either \(P = NP\) or our assumption that an algorithm \(\mathcal{A}\) can exist was wrong.

  % glossary entry for np complete
\end{proof}

% crossing
\section{An approximation algorithm for BTSPP}
For paths \gls{btsp} is a bit more complicated since compared to normal \gls{btsp} we have less symmetry in the problem. Here there are dedicated vertices \(s\) and \(t\) while for \gls{btsp} it does not matter where to start.


% more difficult
% crossing can be necessary